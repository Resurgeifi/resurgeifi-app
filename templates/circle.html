{% extends "base.html" %}

{% block title %}The Circle{% endblock %}

{% block content %}
<div class="container py-4 mb-5">
    <h2 class="mb-4 text-center">The Circle</h2>

    <div id="chat-box" class="border p-3 bg-white rounded shadow-sm" style="height: 500px; overflow-y: auto;">
        {% if session["circle_thread"] %}
            {% for msg in session["circle_thread"] %}
                <div><strong>{{ msg.speaker }}:</strong> {{ msg.text }}</div>
            {% endfor %}
        {% else %}
            <p class="text-muted">The Circle is quiet... for now.</p>
        {% endif %}
    </div>

    <form id="circleForm" class="mt-4 d-flex">
        <textarea id="userMessage" class="form-control me-2" rows="1" placeholder="Type something or just listen..."></textarea>
        <button type="submit" class="btn btn-primary">Send</button>
    </form>

    <div class="text-end mt-3">
        <button class="btn btn-secondary" id="reflectBtn">🪞 Summarize Journal</button>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener("DOMContentLoaded", () => {
        const form = document.getElementById("circleForm");
        const chatBox = document.getElementById("chat-box");
        const messageInput = document.getElementById("userMessage");

        form.addEventListener("submit", async (e) => {
            e.preventDefault();
            const message = messageInput.value.trim();
            if (!message) return;

            const userDiv = document.createElement("div");
            userDiv.innerHTML = `<strong>You:</strong> ${message}`;
            chatBox.appendChild(userDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
            messageInput.value = "";

            try {
                const res = await fetch("/ask", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ message })
                });

                const data = await res.json();

                for (const reply of data.messages) {
                    const typingDiv = document.createElement("div");
                    typingDiv.innerHTML = `<em>${reply.hero} is typing...</em>`;
                    chatBox.appendChild(typingDiv);
                    chatBox.scrollTop = chatBox.scrollHeight;

                    await new Promise(resolve => setTimeout(resolve, reply.delay_ms));
                    typingDiv.remove();

                    const replyDiv = document.createElement("div");
                    replyDiv.innerHTML = `<strong>${reply.hero}:</strong> ${reply.text}`;
                    chatBox.appendChild(replyDiv);
                    chatBox.scrollTop = chatBox.scrollHeight;
                }
            } catch (err) {
                const errorDiv = document.createElement("div");
                errorDiv.innerHTML = `<strong>Error:</strong> Could not reach the Circle.`;
                chatBox.appendChild(errorDiv);
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        });

        // ⏳ Idle Check — ping every 15s
        setInterval(async () => {
            try {
                const res = await fetch("/idle-check");
                const data = await res.json();

                if (data.idle && data.message) {
                    const replyDiv = document.createElement("div");
                    replyDiv.innerHTML = `<strong>${data.message.speaker}:</strong> ${data.message.text}`;
                    chatBox.appendChild(replyDiv);
                    chatBox.scrollTop = chatBox.scrollHeight;
                }
            } catch (err) {
                console.error("Idle check failed", err);
            }
        }, 15000);

        // 🪞 Redirect to auto-summarized journal
        document.getElementById("reflectBtn").addEventListener("click", () => {
            window.location.href = "/summarize-journal";
        });
    });
</script>
{% endblock %}
